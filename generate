#!/usr/bin/env node

var fs = require('fs');
var glob = require('glob');
var path = require('path');
var log = require('npmlog');
var mkdirp = require('mkdirp');
var pluralize = require('pluralize');
var camelCase = require('lodash.camelcase');
var kebabCase = require('lodash.kebabcase');
var snakeCase = require('lodash.snakecase');
var upperFirst = require('lodash.upperfirst');
var Promise = require('bluebird');
var pkg = require('./package.json');

require('cli-program')
    .name('generate')
    .version(pkg.version)
    .description('Generate files by templates')
    .option('-c, --cwd [string]')
    .arguments('<source> <target> [models...]')
    .parse(function (args, opts) {
        var base = opts.cwd ? path.resolve(process.cwd(), opts.cwd) : process.cwd();
        var models = args.models;
        var source = path.resolve(base, args.source);
        var target = path.resolve(base, args.target);
        log.info('generate', 'Source: %s', source);
        log.info('generate', 'Target: %s', target);
        glob('**/*', {cwd: source}, function (error, files) {
            if (error) {
                log.error('generate', error.stack || error.message || error);
            } else {
                Promise.all(models.map(function (model) {
                    return Promise.all(files.map(function (file) {
                        return generate(model, source, target, file);
                    }));
                }));
            }
        });
    });

function mkdir(path) {
    return new Promise(function (resolve, reject) {
        mkdirp(path, function (error) {
            if (error) {
                reject(error);
            } else {
                resolve();
            }
        });
    });
}

function readFile(path) {
    return new Promise((resolve, reject) => {
        fs.readFile(path, {encoding: 'utf8'}, (error, content) => {
            if (error) {
                reject(error);
            } else {
                resolve(content);
            }
        });
    });
}

function writeFile(path, content) {
    return new Promise((resolve, reject) => {
        fs.writeFile(path, content, (error) => {
            if (error) {
                reject(error);
            } else {
                resolve();
            }
        })
    })
}

function replace(content, model) {
    return content
        .replace(/\${year}/g, new Date().getFullYear().toString())
        .replace(/TemplateModels/g,  camelCase(model) === camelCase(pluralize(model)) ?
            upperFirst(camelCase(model)) + 'List' : upperFirst(camelCase(pluralize(model))))
        .replace(/TemplateModel/g,   upperFirst(camelCase(model)))
        .replace(/templateModels/g,  camelCase(model) === camelCase(pluralize(model)) ?
            camelCase(model) + 'Collection' : camelCase(pluralize(model)))
        .replace(/templateModel/g,   camelCase(model))
        .replace(/template-models/g, kebabCase(model) === kebabCase(pluralize(model)) ?
            kebabCase(pluralize(model)) + '-list' : kebabCase(pluralize(model)))
        .replace(/template-model/g,  kebabCase(model))
        .replace(/template-models/g, snakeCase(model) === snakeCase(pluralize(model)) ?
            snakeCase(pluralize(model)) + '-list' : snakeCase(pluralize(model)))
        .replace(/template-model/g,  snakeCase(model));
}

function generate(model, source, target, file) {
    const filename = replace(path.join(target, file), model);
    return readFile(path.join(source, file))
        .then(function (content) {
            return mkdir(path.dirname(filename))
                .then(function () {
                    return replace(content, model);
                });
        })
        .then(function (content) {
            return writeFile(filename, content);
        })
        .then(function () {
            log.info('generate', 'Create: %s', filename);
        })
        .catch(function (error) {
            log.error('generate', error.stack || error.message || error);
        });
}
